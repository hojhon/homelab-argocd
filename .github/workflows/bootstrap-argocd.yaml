name: 1 - Bootstrap ArgoCD

on:
  workflow_dispatch:  # Manual trigger only

jobs:
  bootstrap:
    runs-on: [self-hosted, dev-ops]
    environment: homelab-variables
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure Kubeconfig
        run: |
          if [ -f "/home/github-runner/.kube/config" ]; then
            echo "KUBECONFIG=/home/github-runner/.kube/config" >> $GITHUB_ENV
          elif [ -f "/etc/rancher/k3s/k3s.yaml" ]; then
            cp /etc/rancher/k3s/k3s.yaml kubeconfig.yaml
            chmod 600 kubeconfig.yaml
            echo "KUBECONFIG=$(pwd)/kubeconfig.yaml" >> $GITHUB_ENV
          else
            echo "No kubeconfig found on runner" >&2
            exit 1
          fi

      - name: Create Namespaces and Secrets
        env:
          ARGOCD_PASS: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}
          CF_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          CF_HOJHON_SITE: ${{ secrets.CF_HOJHON_SITE }}
          DOCKERHUB_USER: ${{ secrets.DOCKER_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKER_PASSWORD }}
        run: |
          kubectl --kubeconfig="$KUBECONFIG" create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl --kubeconfig="$KUBECONFIG" create namespace cloudflare --dry-run=client -o yaml | kubectl apply -f -
          kubectl --kubeconfig="$KUBECONFIG" create namespace hojhon-site --dry-run=client -o yaml | kubectl apply -f -

          # Fail fast if CLOUDFLARE_TUNNEL_TOKEN is not available in this run (common with protected environments)
          if [ -z "$CF_TOKEN" ]; then
            echo "ERROR: CLOUDFLARE_TUNNEL_TOKEN is empty or not accessible in this run. Check repository/environment secrets and approvals." >&2
            exit 1
          fi

          # Generate a random secret key for the ArgoCD server
          ARGOCD_SECRET_KEY=$(openssl rand -base64 32)

          # Create ArgoCD secret with both the admin password and the server secret key
          kubectl --kubeconfig="$KUBECONFIG" -n argocd create secret generic argocd-secret \
            --from-literal=admin.password="$ARGOCD_PASS" \
            --from-literal=admin.passwordMtime="$(date +%FT%T%Z)" \
            --from-literal=server.secretkey="$ARGOCD_SECRET_KEY" \
            --dry-run=client -o yaml | kubectl apply --validate=false -f -
          
          # Protect ArgoCD secret from being overwritten
          kubectl --kubeconfig="$KUBECONFIG" -n argocd annotate secret argocd-secret \
            helm.sh/resource-policy=keep --overwrite

          # ==========================================
          # ARGOCD TUNNEL SECRETS (uses CF_TOKEN)
          # ==========================================
          
          # Create ArgoCD tunnel secret
          kubectl --kubeconfig="$KUBECONFIG" -n cloudflare create secret generic cloudflared-argocd-tunnel-secret \
            --from-literal=tunnelToken="$CF_TOKEN" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Add the helm.sh/resource-policy: keep annotation
          kubectl --kubeconfig="$KUBECONFIG" -n cloudflare annotate secret cloudflared-argocd-tunnel-secret \
            helm.sh/resource-policy=keep --overwrite

          # Create Helm-generated secret name for ArgoCD tunnel
          kubectl --kubeconfig="$KUBECONFIG" -n cloudflare create secret generic cloudflared-cloudflare-tunnel-remote \
            --from-literal=tunnelToken="$CF_TOKEN" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Add the helm.sh/resource-policy: keep annotation
          kubectl --kubeconfig="$KUBECONFIG" -n cloudflare annotate secret cloudflared-cloudflare-tunnel-remote \
            helm.sh/resource-policy=keep --overwrite

          # ==========================================
          # HOJHON-SITE TUNNEL SECRETS (uses CF_HOJHON_SITE)
          # ==========================================

          # Create hojhon-site tunnel secret (if token provided)
          if [ -n "$CF_HOJHON_SITE" ]; then
            # Create hojhon-site tunnel secret
            kubectl --kubeconfig="$KUBECONFIG" -n hojhon-site create secret generic hojhon-site-tunnel-secret \
              --from-literal=tunnelToken="$CF_HOJHON_SITE" \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Add the helm.sh/resource-policy: keep annotation
            kubectl --kubeconfig="$KUBECONFIG" -n hojhon-site annotate secret hojhon-site-tunnel-secret \
              helm.sh/resource-policy=keep --overwrite

            # Create Helm-generated secret name for hojhon-site tunnel
            kubectl --kubeconfig="$KUBECONFIG" -n hojhon-site create secret generic hojhon-cloudflared-cloudflare-tunnel-remote \
              --from-literal=tunnelToken="$CF_HOJHON_SITE" \
              --dry-run=client -o yaml | kubectl apply -f -
            
            # Add the helm.sh/resource-policy: keep annotation
            kubectl --kubeconfig="$KUBECONFIG" -n hojhon-site annotate secret hojhon-cloudflared-cloudflare-tunnel-remote \
              helm.sh/resource-policy=keep --overwrite
          else
            echo "CF_HOJHON_SITE not provided; skipping hojhon-site tunnel secret creation"
          fi

          # Create docker-registry secret in default and hojhon-site namespaces for image pulls (if credentials provided)
          if [ -n "$DOCKERHUB_USER" ] && [ -n "$DOCKERHUB_TOKEN" ]; then
            # Create in default namespace (for any apps that still use it)
            kubectl --kubeconfig="$KUBECONFIG" -n default delete secret dockerhub-regcred --ignore-not-found
            kubectl --kubeconfig="$KUBECONFIG" -n default create secret docker-registry dockerhub-regcred \
              --docker-username="$DOCKERHUB_USER" \
              --docker-password="$DOCKERHUB_TOKEN" \
              --docker-server=https://index.docker.io/v1/ || true
            
            # Protect DockerHub secret from being overwritten
            kubectl --kubeconfig="$KUBECONFIG" -n default annotate secret dockerhub-regcred \
              helm.sh/resource-policy=keep --overwrite

            # Create in hojhon-site namespace
            kubectl --kubeconfig="$KUBECONFIG" -n hojhon-site delete secret dockerhub-regcred --ignore-not-found
            kubectl --kubeconfig="$KUBECONFIG" -n hojhon-site create secret docker-registry dockerhub-regcred \
              --docker-username="$DOCKERHUB_USER" \
              --docker-password="$DOCKERHUB_TOKEN" \
              --docker-server=https://index.docker.io/v1/ || true
            
            # Protect DockerHub secret from being overwritten in hojhon-site namespace
            kubectl --kubeconfig="$KUBECONFIG" -n hojhon-site annotate secret dockerhub-regcred \
              helm.sh/resource-policy=keep --overwrite
          else
            echo "DOCKERHUB_USERNAME/DOCKERHUB_TOKEN not provided; skipping dockerhub-regcred creation"
          fi

      - name: Install ArgoCD CLI
        run: |
          echo "Installing ArgoCD CLI..."
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64

      - name: Delete Existing ArgoCD Resources
        run: |
          echo "Deleting existing ArgoCD resources to handle immutable field changes..."
          kubectl --kubeconfig="$KUBECONFIG" delete deployment -n argocd --all --ignore-not-found
          kubectl --kubeconfig="$KUBECONFIG" delete statefulset -n argocd --all --ignore-not-found

      - name: Install Core ArgoCD Controller
        run: |
          echo "Applying official ArgoCD install manifest..."
          kubectl --kubeconfig="$KUBECONFIG" apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

      - name: Wait for Initial ArgoCD Server
        run: |
          echo "Waiting for the initial argocd-server deployment..."
          kubectl --kubeconfig="$KUBECONFIG" wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

      - name: Apply the Root Application for GitOps
        run: |
          echo "Applying the root application to hand over control to GitOps..."
          kubectl --kubeconfig="$KUBECONFIG" apply -f homelab-apps/root-application.yaml
          
          echo "Applying the hojhon-site application..."
          kubectl --kubeconfig="$KUBECONFIG" apply -f homelab-apps/hojhon-site-app.yaml

      - name: Wait for GitOps Handover to Complete
        run: |
          echo "Waiting for the root application to sync..."
          kubectl --kubeconfig="$KUBECONFIG" wait --for=jsonpath='{.status.health.status}'=Healthy \
            --timeout=300s -n argocd application/root
          
          echo "Waiting for all applications to be synced..."
          sleep 30
          kubectl --kubeconfig="$KUBECONFIG" get applications -n argocd
          echo "Bootstrap complete! ArgoCD is now managing all applications from Git."

      - name: Configure Repository Access
        env:
          ARGO_PAT: ${{ secrets.ARGO_PAT }}
          ARGOCD_ADMIN_PASSWORD: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}
        run: |
          echo "Waiting for ArgoCD server to be fully ready..."
          kubectl --kubeconfig="$KUBECONFIG" wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

          # Port forward ArgoCD server to localhost:8080 in background and keep PID
          echo "Starting port-forward to access ArgoCD on localhost:8080..."
          kubectl --kubeconfig="$KUBECONFIG" port-forward -n argocd svc/argocd-server 8080:443 --address 127.0.0.1 > /dev/null 2>&1 &
          PF_PID=$!

          # Give port-forward a moment to start
          for i in 1 2 3 4 5; do
            sleep 2
            if nc -z 127.0.0.1 8080 >/dev/null 2>&1; then
              break
            fi
          done

          # Determine admin password: prefer the generated initial password (unique) if available; otherwise fallback to ARGOCD_ADMIN_PASSWORD
          ADMIN_PW=$(kubectl --kubeconfig="$KUBECONFIG" -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' 2>/dev/null | base64 --decode || true)
          if [ -n "$ADMIN_PW" ]; then
            echo "Using initial admin password from argocd-initial-admin-secret"
          elif [ -n "$ARGOCD_ADMIN_PASSWORD" ]; then
            ADMIN_PW="$ARGOCD_ADMIN_PASSWORD"
            echo "Using ARGOCD_ADMIN_PASSWORD from secrets"
          else
            echo "No ArgoCD admin password available (neither initial secret nor ARGOCD_ADMIN_PASSWORD)." >&2
            kill $PF_PID || true
            exit 1
          fi


          # Login to ArgoCD using determined password (quote to avoid special-char issues)
          echo "Logging into ArgoCD..."
          argocd login 127.0.0.1:8080 --username admin --password "$ADMIN_PW" --insecure || {
            echo "ArgoCD login failed" >&2
            kill $PF_PID || true
            exit 1
          }

          echo "Configuring repository access in ArgoCD..."
          argocd repo add https://github.com/hojhon/homelab-argocd.git \
            --username "hojhon" \
            --password "$ARGO_PAT" \
            --insecure-skip-server-verification || true
          # Clean up port-forward
          kill $PF_PID || true

      - name: Clean up
        if: always()
        run: rm -f kubeconfig.yaml || true