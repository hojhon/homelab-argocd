name: Deploy ArgoCD

on:
  workflow_dispatch:  # Manual trigger only

jobs:
  deploy:
    runs-on: [self-hosted, dev-ops]
    environment: homelab-variables
    steps:
      - uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubeconfig
        run: |
            # Prefer kubeconfig installed by setup-runner.sh
            if [ -f "/home/github-runner/.kube/config" ]; then
              echo "KUBECONFIG=/home/github-runner/.kube/config" >> $GITHUB_ENV
              kubectl --kubeconfig=/home/github-runner/.kube/config version --client=true || true
            elif [ -f "/etc/rancher/k3s/k3s.yaml" ]; then
              # Fallback: copy k3s kubeconfig locally
              cp /etc/rancher/k3s/k3s.yaml kubeconfig.yaml
              chmod 600 kubeconfig.yaml || true
              echo "KUBECONFIG=$(pwd)/kubeconfig.yaml" >> $GITHUB_ENV
              kubectl --kubeconfig=$(pwd)/kubeconfig.yaml version --client=true || true
            else
              echo "No kubeconfig found on runner" >&2
              exit 1
            fi

      - name: Debug kubectl/KUBECONFIG
        run: |
          echo "KUBECONFIG=${KUBECONFIG}"
          test -f "$KUBECONFIG" && ls -l "$KUBECONFIG" || { echo "KUBECONFIG file missing"; exit 1; }
          echo "server entries:" && grep -n 'server:' "$KUBECONFIG" || true
          echo "kubectl client version:" && kubectl --kubeconfig="$KUBECONFIG" version --client=true || true
          echo "cluster-info:" && kubectl --kubeconfig="$KUBECONFIG" cluster-info || true
          echo "nodes:" && kubectl --kubeconfig="$KUBECONFIG" get nodes -o wide || true
          echo "auth can-i create ns:" && kubectl --kubeconfig="$KUBECONFIG" auth can-i create ns || true

      - name: Create namespaces
        run: |
          kubectl --kubeconfig="$KUBECONFIG" create namespace argocd --dry-run=client -o yaml | kubectl --kubeconfig="$KUBECONFIG" apply -f - --validate=false
          kubectl --kubeconfig="$KUBECONFIG" create namespace cloudflare --dry-run=client -o yaml | kubectl --kubeconfig="$KUBECONFIG" apply -f - --validate=false

      - name: Create ArgoCD admin password
        run: |
          kubectl --kubeconfig="$KUBECONFIG" -n argocd create secret generic argocd-secret \
            --from-literal=admin.password="${{ secrets.ARGOCD_ADMIN_PASSWORD }}" \
            --from-literal=admin.passwordMtime="$(date +%FT%T%Z)" \
            --dry-run=client -o yaml | \
              kubectl --kubeconfig="$KUBECONFIG" apply --validate=false -f -

      - name: Create Cloudflared tunnel token
        run: |
          kubectl --kubeconfig="$KUBECONFIG" -n cloudflare create secret generic cloudflared-cloudflare-tunnel-remote \
            --from-literal=tunnelToken="${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}" \
            --dry-run=client -o yaml | \
              kubectl --kubeconfig="$KUBECONFIG" apply --validate=false -f -

      - name: Apply ArgoCD
        run: |
         kubectl --kubeconfig="$KUBECONFIG" apply --validate=false -f apps/argocd.yaml
         kubectl --kubeconfig="$KUBECONFIG" -n argocd wait --timeout=60s --for=condition=established crd/applications.argoproj.io || true

      - name: Wait for ArgoCD to be ready
        run: |
         kubectl --kubeconfig="$KUBECONFIG" -n argocd wait --for=condition=available --timeout=300s deployment/argocd-server || true
          sleep 30  # Give additional time for services to stabilize

      - name: Apply Cloudflared
        run: kubectl --kubeconfig="$KUBECONFIG" apply --validate=false -f apps/cloudflared.yaml

      - name: Clean up
        if: always()
        run: |
          rm -f kubeconfig.yaml || true