name: Refresh ArgoCD Application

on:
  workflow_dispatch:
    inputs:
      app_name:
        description: 'ArgoCD Application Name to Refresh'
        required: true
        type: choice
        options:
          - 'hojhon-site-app'
          - 'vault-app'
          - 'root-application'
        default: 'hojhon-site-app'
      sync_strategy:
        description: 'Sync Strategy'
        required: true
        type: choice
        options:
          - 'refresh-only'
          - 'soft-sync'
          - 'hard-sync'
        default: 'refresh-only'
      restart_deployment:
        description: 'Restart deployment to pull latest image (for :latest tags)'
        required: false
        type: boolean
        default: false

jobs:
  refresh-app:
    runs-on: [self-hosted, dev-ops]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure Kubeconfig
        run: |
          if [ -f "/home/github-runner/.kube/config" ]; then
            echo "KUBECONFIG=/home/github-runner/.kube/config" >> $GITHUB_ENV
            echo "‚úÖ Using GitHub runner kubeconfig"
          elif [ -f "/etc/rancher/k3s/k3s.yaml" ]; then
            cp /etc/rancher/k3s/k3s.yaml kubeconfig.yaml
            chmod 600 kubeconfig.yaml
            echo "KUBECONFIG=$(pwd)/kubeconfig.yaml" >> $GITHUB_ENV
            echo "‚úÖ Using K3s kubeconfig"
          else
            echo "‚ùå No kubeconfig found on runner"
            exit 1
          fi

      - name: Verify kubectl connection
        run: |
          echo "üîß Testing kubectl connection..."
          echo "User: $(whoami)"
          echo "KUBECONFIG: $KUBECONFIG"
          
          # Test kubectl connection
          if kubectl version --short >/dev/null 2>&1; then
            echo "‚úÖ kubectl is connected to cluster"
            kubectl cluster-info --request-timeout=5s
          else
            echo "‚ùå kubectl connection failed"
            exit 1
          fi
          
          # Verify ArgoCD namespace exists
          if kubectl get namespace argocd >/dev/null 2>&1; then
            echo "‚úÖ ArgoCD namespace found"
          else
            echo "‚ùå ArgoCD namespace not found"
            kubectl get namespaces
            exit 1
          fi

      - name: Validate Application Exists
        run: |
          echo "üîç Checking if application '${{ github.event.inputs.app_name }}' exists..."
          
          # List all applications first for debugging
          echo "Available applications:"
          kubectl --kubeconfig="$KUBECONFIG" get applications -n argocd --no-headers -o custom-columns="NAME:.metadata.name" || true
          
          # Check if the specific application exists
          if kubectl --kubeconfig="$KUBECONFIG" get application ${{ github.event.inputs.app_name }} -n argocd >/dev/null 2>&1; then
            echo "‚úÖ Application '${{ github.event.inputs.app_name }}' found"
          else
            echo "‚ùå Application '${{ github.event.inputs.app_name }}' not found in ArgoCD"
            echo "Available applications in argocd namespace:"
            kubectl --kubeconfig="$KUBECONFIG" get applications -n argocd -o name | sed 's|application.argoproj.io/||'
            exit 1
          fi

      - name: Get Current Application Status
        run: |
          echo "üìä Current application status:"
          kubectl get application ${{ github.event.inputs.app_name }} -n argocd -o jsonpath='{.status.sync.status}' | xargs echo "Sync Status:"
          kubectl get application ${{ github.event.inputs.app_name }} -n argocd -o jsonpath='{.status.health.status}' | xargs echo "Health Status:"
          echo ""
          echo "üïê Last operation:"
          kubectl get application ${{ github.event.inputs.app_name }} -n argocd -o jsonpath='{.status.operationState.finishedAt}' | xargs echo "Finished At:"

      - name: Execute Sync Strategy
        run: |
          APP_NAME="${{ github.event.inputs.app_name }}"
          STRATEGY="${{ github.event.inputs.sync_strategy }}"
          
          echo "üöÄ Executing '$STRATEGY' for application '$APP_NAME'..."
          
          case $STRATEGY in
            "refresh-only")
              echo "üîÑ Refreshing application (checks for changes without syncing)..."
              kubectl patch application $APP_NAME -n argocd --type merge -p '{"operation":{"sync":{"revision":"HEAD"}}}'
              ;;
              
            "soft-sync")
              echo "üîÑ Performing soft sync (respects ignore differences)..."
              kubectl patch application $APP_NAME -n argocd --type merge -p '{"operation":{"sync":{"revision":"HEAD","syncStrategy":{"apply":{"force":false}}}}}'
              ;;
              
            "hard-sync")
              echo "üí™ Performing hard sync (ignores ignore differences)..."
              kubectl patch application $APP_NAME -n argocd --type merge -p '{"operation":{"sync":{"revision":"HEAD","syncStrategy":{"apply":{"force":true}}}}}'
              ;;
          esac

      - name: Wait for Sync Completion
        run: |
          echo "‚è≥ Waiting for sync to complete..."
          
          # Wait up to 5 minutes for sync to complete
          timeout=300
          interval=10
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            status=$(kubectl get application ${{ github.event.inputs.app_name }} -n argocd -o jsonpath='{.status.sync.status}')
            operation_phase=$(kubectl get application ${{ github.event.inputs.app_name }} -n argocd -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "")
            
            echo "Current status: $status, Operation: $operation_phase"
            
            if [[ "$status" == "Synced" && "$operation_phase" != "Running" ]]; then
              echo "‚úÖ Application successfully synced!"
              break
            fi
            
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "‚ö†Ô∏è  Timeout waiting for sync completion"
          fi

      - name: Restart Deployment (if requested)
        if: ${{ github.event.inputs.restart_deployment == 'true' }}
        run: |
          APP_NAME="${{ github.event.inputs.app_name }}"
          echo "üîÑ Restarting deployment to pull latest image for '$APP_NAME'..."
          
          # Map ArgoCD app names to deployment info
          case $APP_NAME in
            "hojhon-site-app")
              NAMESPACE="hojhon-site"
              DEPLOYMENT="hojhon-site"
              ;;
            "vault-app")
              NAMESPACE="vault"
              DEPLOYMENT="vault"
              ;;
            *)
              echo "‚ö†Ô∏è  Deployment restart not configured for '$APP_NAME'"
              exit 0
              ;;
          esac
          
          # Check if deployment exists
          if kubectl get deployment $DEPLOYMENT -n $NAMESPACE >/dev/null 2>&1; then
            echo "üîÑ Restarting deployment '$DEPLOYMENT' in namespace '$NAMESPACE'..."
            kubectl rollout restart deployment/$DEPLOYMENT -n $NAMESPACE
            
            echo "‚è≥ Waiting for rollout to complete..."
            kubectl rollout status deployment/$DEPLOYMENT -n $NAMESPACE --timeout=300s
            
            echo "‚úÖ Deployment restart completed"
          else
            echo "‚ö†Ô∏è  Deployment '$DEPLOYMENT' not found in namespace '$NAMESPACE'"
          fi

      - name: Get Final Application Status
        run: |
          echo "üìä Final application status:"
          kubectl get application ${{ github.event.inputs.app_name }} -n argocd -o jsonpath='{.status.sync.status}' | xargs echo "Sync Status:"
          kubectl get application ${{ github.event.inputs.app_name }} -n argocd -o jsonpath='{.status.health.status}' | xargs echo "Health Status:"
          echo ""
          echo "üèÅ Operation completed at:"
          kubectl get application ${{ github.event.inputs.app_name }} -n argocd -o jsonpath='{.status.operationState.finishedAt}' | xargs echo
          
          # Show pods if this is a deployment application
          if [[ "${{ github.event.inputs.app_name }}" == "hojhon-site-app" ]]; then
            echo ""
            echo "üîç Current pods in hojhon-site namespace:"
            kubectl get pods -n hojhon-site -l app=hojhon-site --no-headers | while read line; do
              echo "  $line"
            done
          fi

      - name: Summary
        if: always()
        run: |
          echo ""
          echo "üéØ Operation Summary:"
          echo "===================="
          echo "Application: ${{ github.event.inputs.app_name }}"
          echo "Strategy: ${{ github.event.inputs.sync_strategy }}"
          echo "Restart Deployment: ${{ github.event.inputs.restart_deployment }}"
          echo "Status: ${{ job.status }}"
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"